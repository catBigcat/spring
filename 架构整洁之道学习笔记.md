

# 架构整洁之道学习笔记

## 一、架构与设计到底是什么



### 架构architecture  与设计 design 区别？

没有区别，只是在不同层次的表示罢了。一般设计往往是系统底层组织结构和实现。 架构往往是把底层排除在外。



### 架构解决的什么问题：

架构的终极目标是 用最小的人力成本来满足构建和维护该系统的需求。



### 本章建议的几个事情：

1、慢但是稳，是成功的秘诀。

2、该比赛并不是拼谁开始跑得快，也不是拼谁更有力气。

3、心态越急，反而跑的更慢。

现代的软件研发工程师 有点过于自信，持续低估那些好的、良好设计的、整洁的代码的重要性。

工程师总是忙于完成新功能，新功能总是做不完的，哪有时间重构老代码。

<font color="red">研发错误观点之一： 我们可以以后再重构代码，产品上线最重要。</font>

**评论： 这往往就是个两难的问题，没有那么多时间去搞这么多事情。选择敏捷开发的问题在于 需求确认的困难，往往是代码写完之后，才知道那些细节需要调整。软件磨损往往是需求变更导致的。**

<font color="red">工程师错误观点二： 胡乱编写代码的工作速度其实比循规蹈矩的更慢。</font>

这个观点还是要取决于未来的预期，代码是一次性的，还是需要长期的维护。





## 二、 价值维度

### 行为价值

软件系统的行为是最直观的价值维度。 机器按照指定方式运转，给系统的使用者创造或者提高利润。

<font color = 'red'>程序员误区： 认为他们的工作只是按照需求文档编写代码，修复bug。</font>

### 架构价值

软件的灵活性是价值维度的第二个体现。

软件系统应该容易被修改。变更的难度应该与变更的范畴成等比关系，而与变更的具体形状无关。

这句话的含义应该是： 应该使用良好的概念设计，将相关问题分解，尽可能避免耦合。



### 哪个价值维度更重要

对于业务部门来说，他们通常认为系统正常工作很重要。但是系统开发人员采用这种方式危害很大。



### 艾尔森威尔矩阵

| 重要且紧急   | 重要不紧急     |
| ------------ | -------------- |
| 不重要但紧急 | 不重要且不紧急 |



## 三、结构化编程



### 通过形式化的证明手段来确保软件正确。

<font color='red'>我现在有欠缺。因为练习的时候很少使用形式化的证明方法来确保程序正确。</font>

借鉴 数学中的公理、定理、推论和引理的方式来形成欧几里得结构。

程序员可以像数学家一样对自己的程序进行推理证明。

程序员可以将一些已证明可用的结构串联起来，只要自行证明这些额外代码是正确的，就可以推导出整个程序的正确性。

bohm 和jocopini证明了 顺序结构、分支结构、循环结构三种结构可以构造出任何程序（我们编程只使用这三种结构）。

我们构造可推到模块所需要的控制结构集与构造所有程序所需要的控制结构的最小集合是等同的。

避免go语言，因为go严重破坏结构，导致证明困难与复杂。

<font color='red'>但是，在实践过程中，形式化验证比较麻烦。几乎没有程序员认为形式化验证是产出高质量软件的条件。</font>

由于缺少形式化证明，我只能去尝试证伪。 证伪就是编写测试用例，但是完全证明不存在bug。



### 功能降解与拆分

结构化编程范式 将模块递归分解成 可推导的单元，以为这模块按照功能进行拆解。

从高级功能到低级语义的拆解。



## 四、 面向对象编程

### 什么是面向对象编程

一种说法是数据与函数的组合。也有说是 对真实世界的建模。

面向对象是支持封装、继承、多态的组合。

* 封装 是屏蔽细节。 将数据和函数圈起来，圈外代码只能看到部分函数，数据则完全不可见。

* 继承可以在某个作用域之外对外部定义的一组变量与函数进行覆盖。
* 变量多态是指：基类型的变量（对于C++是引用或指针）可以被赋值基类型对象，也可以被赋值派生类型的对象。函数多态是指，相同的函数调用界面（函数名与实参表），传送给一个对象变量，可以有不同的行为，这视该对象变量所指向的对象类型而定。因此，变量多态是函数多态的基础。

面向对象在表现上对程序的间接控制权的转移进行了约束。（相比于c，消除了多态实现上的约定）



## 依赖反转

他主要是 实现上是具体的类或者方法，代码显性写的是接口或者其他的高层的抽象。

该名称 主要是只  接口和实现类的继承关系于控制流的方向正好相反，所以称之为依赖反转。面向对象在上面提到的多态中，可以很方便的实现反转。
MVC 就是典型的依赖反转。 将业务切分成 M V C 对应 数据、视图、业务，三个模块之间仅仅通过高层接口进行调用。



## 五、函数式编程

通过 lanmda 演算来建模的一种结构化编程的形式。

函数式编程与面向对象的重大区别是 java中使用的可变量，但是函数式里面是不可变量。

竞争问题、死锁问题、并发更新问题都是可变变量导致的。

<font color='red'>该函数式编程 是给我展示的 将可变量做成不可变的量、从而避免竞争、死锁、并发更新问题。</font>

### 可变性的隔离

应用程序或者内部服务在划分的时候 分成可变的和不可变的组建。不可变组件以纯函数的方式来执行，然后通过一个或多个非函数组建通信通信的方式来更新状态。

### 事件溯源

只存储记录、不存储状态信息，由于从CRUD 改成CR，导致不存在并发问题。



## 总结：

* 结构化编程是对程序控制权的直接转移的限制。

限制了goto 语句，以最小的 顺序结构 分支结构和循环结构来实现程序。该程序与形式化证明 相辅相成的。

* 面向对象是对程序控制圈的间接转移的限制。

在实现多态的时候，传统c语言需要显性的指定 函数，从而是实现多态，但是，由于灵活的控制，并不一定每个人都遵守这个约定，而面向对象在语言上约定了这个契约。

* 函数式编程是对程序中赋值操作的限制。

函数式编程都是不可变量，而可变量是导致 竞争问题、死锁问题和并发更新问题的原因。



## 六、设计原则

SOLID 主要作用是 告诉我们怎么将数据和函数组织成类，以及如何将这些类连接起来成为程序。

该问题主要是适用于进行模块级编程的程序员。

设计目标：

* 软件容忍被改动。

* 让软件更容易被理解。

* 构建可以在多个软件系统中复用的组件。

SRP（[ Single-responsiblity Principle](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#single-responsibility-principle)）单一职责原则

一个软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构。 这样每一个软件模块都有且仅有一个需要被改变的理由。

<font color='red'>（任何软件都能反映出其制作团队的组织结构，这是因为人们会以他么组织形式工作。项目团队的组织结构中的优缺点都不可避免地反映在他们生成的结果系统中）A class should have one and only one reason to change, meaning that a class should have only one job.</font>



OCP open closed principle

系统软件想要更容易修改，设计成允许新增代码的方式来修改系统行为，而非只靠修改原来的代码。

Objects or entities should be open for extension but closed for modification.



LSP [ Liskov Substitution Principle](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#liskov-substitution-principle) 里氏替换原则

如果想用可替换的组建来替换系统，那么这个组件共同遵守同一个约定，一边让这些组件可以相互替换。



ISP [ Interface Segregation Principle](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#interface-segregation-principle)

接口隔离原则

软件设计是在设计的时候避免不必要的依赖。客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。



DIP [ Dependency Inversion Principle](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#dependency-inversion-principle)

控制反转原则

高层策略性的代码不应该依赖实现底层细节的代码，而那些底层实现细节的代码应该尽可能依赖高层策略性的代码。



## 七、单一职责原则

该功能的定义可能存在误解：

<font color='red'>任何模块都应该只做一件事。 这个也是一个原则，即 确保一个函数只完成一个功能。</font>但这不是 单一职责原则的全部。

任何软件模块都应该只对某一类行为者负责。

代码与数据就是靠着与某一类行为者的相关性被组合在一起的。



算法共享问题：

比如发工资需要满足 计算工时、报告工时、支付薪水。 

假设存在三种用户 coo 、cfo、cto。

在使用的时候，共同依赖计算工时，cfo团队对计算工时进行了修改，导致cto也跟着修改，然后出了严重的问题。（从侧面也反映出软件反映的是团队的组织架构）。



## 八、开闭原则

设计良好的计算机软件应该易于扩展，同时抗拒修改。

现在前后端使用的模式并不是一个良好的符合开闭原则的设计，因为前端的修改需要影响到后端。 

<font color='red'> 阅读训练营里面学习任务并不是很好的设计，因为学习任务是写在外面，而不是在catalog里面。 </font>



## 九、里式替换原则

对于每一个类型是S的对象o1都存在一个类型为T的对象o2，能使操作T类型的程序P在再用o2替换o1是行为保持不变，我们称S为T的子类型。



## 十、接口隔离原则

任何层次的软件设计如果依赖于不需要的东西，都是有害的。



## 十一、依赖反转原则

### 稳定的抽象层

当修改抽象接口的时候，一定也会修改对应的具体的实现。但，反过来，当我们修改具体实现的时候，却很少修改对应的抽象的接口，所以我们认为接口比实现更稳定。

* 在代码中尽可能使用抽象的接口，尽量避免使用那些多变的具体实现类。
* 不要在具体实现类上创建衍生类。
* 不要覆盖具体实现的函数。
* 避免在代码中写入任何具体实现相关的名字，或者其他用以变动的事务名称。



一般情况下，我们会使用工厂模式来解决该问题，spring 中ioc 通常用的是 简单工厂模式，类型作为参数传入。而FactoryBean 是抽象工厂模式，直接生成对应的bean。



<h2></h2>

## 十二、组件

组件是软件的部署单元，是整个软件系统在部署过程中可以独立完成部署的最小试题。

### 组件发展史 当故事看一看就好了

早期 完全掌控自己编写的程序所在的内存地址和存放格式。程序员需要将库函数直接包含在自己程序里面，然后整体编译。（打孔机时代：有几十盒库函数源代码 按照顺序摆在一个书架上、编写程序的时候，就将源代码拿下，放在重新编写的代码后面）。

后来库函数放在了指定的内存地址，类似于windows 给固定的内核地址一样。

重定位技术。 可以重定位的二进制文件。 使用一个智能的加载器加载到任意的内存地址，类似于引入了一个base的基址。

再后来引入连接器：将程序分成多个可以被编译加载的程序段。然后分离编译过程和连接过程。因为连接器需要读取大量的二进制库文件来解析外部引用。

<font color='red'>莫菲定律： 程序的规模会一直不断的增长下去，直到有限的编译和链接时间填满为止。 </font>

后来链接速度提升到已经远远超过程序规模的增长速度。大部分情况下，程序的连接时间降低到了秒（io 提速吧），这对一些小程序来说，使用连接器可以接受了。所以可以实时的连接，插件化的架构成了现实。



## 十三、组件聚合

* REP 复用/发布等同原则

* CCP 共同闭包原则。
* CRP 共同复用原则。

### REP  复用/发布等同原则

软件的复用的最小粒度应等同于其发布的最小粒度。

如果想复用某个软件和组件库，一般必须要求该组件的开发按照某种发布流程来驱动，并且有明确的发布版本号。

<font color='red'>之前在搞的时候，并没这样，因为，这样搞会给一般的开发增加额外的管理工作</font>

没有明确的版本号，我们就没有办法保证所有被复用的组件之间能够彼此兼容。软件的开发必须知道这些组件的发布时间，以及每次发布带来了那些变更。



### ccp  共同闭包原则

我们应该将那些同时修改，并且相同目的而修改的类放在同一组件中，而将不会同时修改，并且不会为了相同目的而修改的那些类放到不同的组件中。

该原则和srp是相同，可以概述为：

将由于相同原因而修改，并且需要同时修改的东西放在一起。将由于不同原因而修改，并且不同时修改的东西分开。



### CRP 共同复用原则

不要强迫一个组件的用户依赖他们不需要的东西。

这个建议 当我们决定依赖某个组件的时候，最好是实际需要依赖该组件中的每一个类。接口隔离原则。

<font color='red'>这个规则是建议不要把common里面啥bean都塞进去</font>

### 组件张力聚合图



![img](https://upload-images.jianshu.io/upload_images/4317553-303e5c22cbe5de36.png?imageMogr2/auto-orient/strip|imageView2/2/w/961/format/webp)

项目开始 会比较关注ccp，然后逐渐向左靠拢。



## 十四、组件耦合

### 组件依赖图不应该出现环。（现在已经出现了）

* 每周重构

中型项目常见手段。每周第五天要求所有人将自己所作的变更提交，进行统一重构。

* 消除循环依赖

将研发项目划分成一些可单独发布的组件，这些组件可以给单人或者一组程序员进行独立完成。完成后，通过发布的机制通知其他程序员，并给组件打版本号。

其他人自行决定是否依赖这些组件。



### 稳定依赖原则 SDP

依赖关系必须指向更加稳定的方向。

设计组件架构图 决定让那些组件稳定，那些组件不稳定。可变更的组件放在结构图的顶部，同时依赖于底层的稳定组件。

### 不稳定性：I = Fan_out/( Fan_in  + Fan_out )

fan_in 入向依赖，组件外部类依赖于组件内部类的数量。

fan_out 出向依赖，组件内部类依赖组件外部类的数量。



### 稳定抽象原则 SAP

一个组件的抽象化的程度应该和其稳定性保持一致。



一般，软件系统中总有一部分是不应该经常发送变更的。这些往往是高层策略，或者一些高层的决策。我们不想这些业务决策和高层架构经常变更。

将高层策略放入稳定组件，又需要底层可以灵活变更，就需要开闭原则来实现。这就要求高层策略需要尽可能使用接口和抽象类。

这等同于 将 SAP（指向） 和SDP（抽象）结合起来等同于组件层次上的 DIP。依赖关系应该指向更加抽象的方向。

### 抽象化程度： A = Na（抽象类和接口数量） / Nc(类的数量)

###  

### 图形化表示

![img](https://upload-images.jianshu.io/upload_images/4317553-edf633b7a0946396.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)

痛苦区稳定，但是非常具体。它很难修改，比如数据库，改起来贼费劲。再比如是工具类。

无用区： 无限抽象，没有被其他组件依赖。过度设计了。



<h1></h1>

## 十五、什么是软件架构



架构师的职责：

<font color='red'>软件架构师其实应该是能力最强的一群程序员，他们通常会在自身承接编程任务的同时，逐步引导整个团队向一个能够最大化生产力的系统设计方向前进。</font>

<font color='red'>如果不亲自承受因系统设计而带来的麻烦，就体会不到设计不佳带来的痛苦，接着就是逐步迷失正确的设计方向。</font>

软件系统的架构质量 是他的创建者决定的，软件架构工作实质 就是 如何将系统切分，并且安排组件之间的排列关系，以及组件之间相互通信的方式。

**如果想设计一个便于推进各项工作的系统，其策略就是要在设计中尽可能长时间地保留可能的可选项。**

软件的架构的终极目标是： 最大化程序员的生产力，同时最小化系统的总体运营成本。



### 开发

一个开发起来困难的软件系统一般不太可能有一个长久、健康的生命周期，所以系统架构的作用就是要方便其开发团队对他的开发。

对于一个只有五个开发人员的小团队，他们完全可以非常高效地共同开发一个没有明确定义组件和接口的系统。软件系统由五个不同的团队合作开发，每个团队都有七个开发人员，一般会逐步成为一个组件对应一个团队。

这个方案主要是 只接受开发进度来驱动，架构设计就会倾向这个方向。

### 部署

部署成本越高，可用性越低。

采用微服务架构利于开发，但是部署的时候令人生畏。配置服务连接和启动时间很容易成为系统出错的来源。（配置中心和网关是很总要的，特别是共有组件配置，最好能统一在一起。）

### 运行

一般情况下，硬件比人力便宜，所以运行问题通常来说都是增加硬件的方式来解决，从而避免软件架构的重新设计。

良好的软件架构应该可以使开发人员对系统的运行过程一目了然（考虑链路追踪 配合swagger）用例、功能以及改系统的必备行为设置为对开发者可见的一级实体简化他们呢对系统的理解。



### 维护

维护成本主要集中在 ’探秘‘ 和’风险‘这两件事上。

 探秘成本主要来自我们对现有软件系统的挖掘，目的是确定新增功能或者被修复问题的最佳位置和最佳方式。了解现有系统。

风险是 进行上述修改时，总是有可能出现新的问题，这种可能性就是风险成本。

### 保持可选项

开发高层策略的时候有意让自己摆脱具体细节的纠缠，这样我们就可以将与具体实现相关的细节决策推迟或延后，因为越到项目后期，我们就拥有越多的信息来做出合理的决策。

一个优秀的软件架构师应该致力于最大化可选项数量。

### 设备无关性

其实就是OCP原则。



## 十六、独立性

良好软件架构需要支持

* 用例与正常运行。
* 系统维护
* 系统开发
* 系统部署

### 用例

开发人员不需要再系统中查找系统所有的行为，而是再系统顶层作为主要元素已经是明确可见的

### 运行

保留组件之间的交互方式，可以根据不停变化的运行需求来转换成各种运行时的线程、进程或服务模型。

### 开发

任何组织在设计系统的时候，往往会复制出一个与该组织内沟通结构相同的系统。

### 部署

一个设计良好的软件架构 可以让系统在构建完成之后能够立即部署。

### 保留可选项

1、无法预知上面所有的情况，并且随着软件发展也会发生变化。所以尽可能保留可选项。

### 按层解耦

用单一职责原则和共同闭包原则 来隔离那些变更原因不同的部分，或者继承变更原因相同的部分。

然后按照稳定性依赖关系，构造出一个水平分层的构件图。

### 用例切分

根据开闭原则，用例也是可以水平切分。比如新订单的用例与删除订单用例发生变更的原因几乎肯定是不同的，按照用例切分也是非常常见的。

### 解耦模式

面对用例隔离后，需要高吞吐和低吞吐的用例自然就分开了。如果数据库和ui也从业务逻辑分离，则可以运行在不同服务器上，更好的分配系统资源。

### 开发独立性

系统解耦之后，干扰大大减少，用例相互隔离，比较好分工。

### 部署独立性

解耦搞的好，那么在系统运行中热切换各个分层实现和用例。

### 重复

别害怕重复，有些不是真正的重复。我们应该尽可能保持系统水平分层的隔离。

### 解耦层次

* 源码层次。 仅仅实现控制源码依赖关系，实现一个模块变动不引起其他模块的变更或重新编译。一般是单体应用。
* 部署层次。 实现一个模块的变更不会引起其他模块的抽更新构造和部署。此时，可能是多进程模型。
* 服务层次。 依赖关系降低到数据结构层级，仅仅通过网络包来实现。



### 十七、 划分边界

边界作用是将软件分割成各种元素，以便约束边界两侧之间的依赖关系。

插拔式架构就是单一职责原则具体体现，SRP作用就是告诉我们在那画线。

为了软件架构中画线，需要先分组件，一部分是核心业务组件，一部分是业务逻辑无关 但是负责提供必要功能的插件，让这些插件依赖于核心业务组件。

这也是DIP和SAP的具体应用。



## 十八 边界剖析

### 跨界调用

边界的一侧函数调用另一层的函数，并且同时传递数据的行为。构造合理的跨边界调用，需要我们对源码中的依赖关系进行合理的管控。

从而减少 其他模块变更、编译、重新部署。

单体：应用必须重新编译。

部署层级的组件：可以配合动态库，从而减少了动态库的调用。

本地进程方式：可以让低层次代码成为高层次代码的一个插件。

服务： 比较容易切分成插件，但是必须更小心控制通信次数。



总之，需要考虑 高通信量、低延迟的本地架构边界和低通信量、高延迟的服务边界。

## 二十 业务逻辑

将应用程序划分成 业务逻辑和插件，需要了解什么是业务逻辑。

业务逻辑 就是 用于带来经济效益的业务业务逻辑和过程。

对于业务逻辑的关键部分则是关键业务逻辑。他所处理的数据就是关键业务数据。

关键业务数据和关键业务逻辑是紧密相关的，适合处理在一起 就是业务实体。

业务实体不关心存储和如何运行，它是高层抽象。

用例属于低层次概念，他描述的是一个特定场景，所以用例依赖业务实体，而业务实体不用依赖用例。

忌讳在输入输出中直接使用业务实体对象引用。违反CCp和单一职责原则，导致代码出现很多分支判断和中间数据。

# 二十一 尖叫的软件架构

良好的架构设计应该围绕用例来展开，这样可以在摆脱框架、工具和使用环境的情况下完整地描述用例。

框架应该是一个可选项。必须带着怀疑的态度来审视每一个框架。应该仔细考虑如何保持对系统用例的关注，避免让框架主导我们的架构设计。



## 二十二 整洁架构

系统架构一些想法如下：

* 六边形架构
* DCI架构
* BCE架构

他们相同点如下：

* 独立于框架
* 可被测试
* 独立于UI
* 独立于数据库
* 独立于任何外部机构（业务逻辑不需要知道任何其他的外部接口的存在）
* 
* ![clip_image001](https://images.cnblogs.com/cnblogs_com/yjf512/201209/201209101000108765.jpg)



越靠近中心，软件层次越高。

源码的依赖关系必须只指向同心圆的内层，由低层次机制指向高层次策略。



### 关键对象如下

业务实体 层 封装系统的关键业务逻辑。

用例是特定业务场景下的业务逻辑。

接口适配器 是数据交换器，负责外层和内层之间数据转换。

框架和驱动程序是工具 数据库 web框架构，包含了各种实现细节。



## 二十三、展示器和谦卑对象

单元测试编写者区分容易测试的行为和难以测试的行为，然后隔离。

设计思路是将他们分成两个模组或类，难以测试的组称为 谦卑humble组。

### 展示器和视图举例

比如 视图是谦卑对象，只负责将数据填充到GUI，不对数据处理。

展示器是可测试对象。可以传值来控制界面显示来测试。

### 数据库网关

由于屏蔽了数据库的细节，可以增加测试桩和测试替身类，来实现可测试的。

### 数据映射器 ORM

ORM属于数据库层，在数据库和数据库网关接口之间建立了谦卑对象的边界。

### 服务监听器

服务的边界处也存在谦卑对象。



## 二十四、不完全边界

设计边界的成本可能太高，并且在敏捷开发里面饱受诟病。但是架构师的工作就是预见性设计！



### 省去最后一步

系统分割成一系列 可以独立编译、部署的组件，再构成一个组件。 省去了版本号管理和发布管理工作。

### 单向边界

单项边界，通过一个临时占位 将来可以被替换成完整架构边界的简单结构。采用传统的策略模式，即可。

### 门户模式

使用一个 facade类，里面放着所有服务函数列表，其他人使用它即可。这样就省去了依赖反转。



## 二十五、 层次与边界

没有一个好的办法来确定要不要引入边界。引入可能过度设计，不引入可能导致变更复杂。



## 二十六、main组件

把主函数入口当作一个插件。负责起始状态、配置信息、加载外部资源、然后控制权交给应用程序的其他高层组件。

也可以设计不同main组件来针对不同的环境。

## 二十七 服务：宏观与微观

服务化可以提高系统的可扩展性和可研发性，但是服务本身不代表系统的架构设计。系统的架构是系统内部的边界，以及边界之间的依赖关系定义的，与通信方式无关。 刘习认为：更多是 独立部署和资源分配隔离上的好处。

## 二十八 测试边界

测试代码也是系统的一部分。

这里将测试视为组件。他在系统最外层，也要遵守依赖关系原则的。

此外，要防止测试代码与系统强耦合，出现脆弱的测试问题，会让系统非常死板，引起抵触。

因为测试也是代码的一部分，不要依赖多变的东西。

比如ui是经常变动的，业务逻辑测试，就不要通过gui测试。

提供测试api来绕开昂贵的资源（如数据库），让其成为 交互器与接口适配器的一个超级。

将测试组件单独构造也是一个好的建议，因为避免到生产环境中进行测试。

## 二十九 整洁的嵌入式编程

软件质量本身不会随时间推移而损耗，但是没有妥善管理的硬件依赖和固件依赖是软件的头号杀手。



软件建构的三个层次：

* 工作起来
* 变好
* 跑的更快

